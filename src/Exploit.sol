// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Synthetix — Stale Oracle Feed Exploit Simulation
/// @notice Educational reproduction of the KRW oracle staleness attack
///         that allowed minting synthetic assets at incorrect prices.

/// @dev Minimal ERC20
contract MockToken {
    string public name;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name, uint8 _decimals) {
        name = _name;
        decimals = _decimals;
    }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function burn(address from, uint256 amount) external {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

/// @dev Simplified oracle that can go stale
contract SimpleOracle {
    struct PriceData {
        uint256 price;
        uint256 updatedAt;
    }

    mapping(bytes32 => PriceData) public prices;
    uint256 public stalePeriod = 3 hours;

    function setPrice(bytes32 currencyKey, uint256 price) external {
        prices[currencyKey] = PriceData(price, block.timestamp);
    }

    /// @notice VULNERABLE: Returns price even if stale
    function getPriceUnsafe(bytes32 currencyKey) external view returns (uint256) {
        return prices[currencyKey].price;
        // ❌ No staleness check!
    }

    /// @notice FIXED: Reverts if price is stale
    function getPriceSafe(bytes32 currencyKey) external view returns (uint256) {
        PriceData memory data = prices[currencyKey];
        require(block.timestamp - data.updatedAt <= stalePeriod, "stale price");
        return data.price;
    }

    function isStale(bytes32 currencyKey) external view returns (bool) {
        return block.timestamp - prices[currencyKey].updatedAt > stalePeriod;
    }
}

/// @dev Simplified Synthetix exchange that converts between synths
contract SimplifiedSynthetix {
    SimpleOracle public oracle;

    mapping(bytes32 => MockToken) public synths;  // currencyKey → synth token
    mapping(address => uint256) public collateral; // SNX collateral

    uint256 public constant COLLATERAL_RATIO = 7500; // 750%
    uint256 public constant BASIS = 1000;

    event Exchange(address indexed user, bytes32 from, uint256 fromAmount, bytes32 to, uint256 toAmount);

    constructor(address _oracle) {
        oracle = SimpleOracle(_oracle);
    }

    function addSynth(bytes32 key, address token) external {
        synths[key] = MockToken(token);
    }

    /// @notice Exchange one synth for another using oracle prices
    /// @dev VULNERABLE: Uses potentially stale oracle price
    function exchangeUnsafe(bytes32 fromKey, uint256 amount, bytes32 toKey) external returns (uint256) {
        MockToken fromSynth = synths[fromKey];
        MockToken toSynth = synths[toKey];

        // ❌ Uses unsafe oracle — may return stale/incorrect price
        uint256 fromPrice = oracle.getPriceUnsafe(fromKey);
        uint256 toPrice = oracle.getPriceUnsafe(toKey);

        // Value in USD: amount * fromPrice
        // Output: valueUSD / toPrice
        uint256 toAmount = (amount * fromPrice) / toPrice;

        fromSynth.burn(msg.sender, amount);
        toSynth.mint(msg.sender, toAmount);

        emit Exchange(msg.sender, fromKey, amount, toKey, toAmount);
        return toAmount;
    }

    /// @notice FIXED exchange with staleness check
    function exchangeSafe(bytes32 fromKey, uint256 amount, bytes32 toKey) external returns (uint256) {
        MockToken fromSynth = synths[fromKey];
        MockToken toSynth = synths[toKey];

        uint256 fromPrice = oracle.getPriceSafe(fromKey);
        uint256 toPrice = oracle.getPriceSafe(toKey);

        uint256 toAmount = (amount * fromPrice) / toPrice;

        fromSynth.burn(msg.sender, amount);
        toSynth.mint(msg.sender, toAmount);

        emit Exchange(msg.sender, fromKey, amount, toKey, toAmount);
        return toAmount;
    }
}
